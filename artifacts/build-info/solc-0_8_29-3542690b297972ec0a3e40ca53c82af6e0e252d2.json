{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_29-3542690b297972ec0a3e40ca53c82af6e0e252d2",
  "solcVersion": "0.8.29",
  "solcLongVersion": "0.8.29+commit.ab55807c",
  "userSourceNameMap": {
    "contracts/Ecdsa.sol": "project/contracts/Ecdsa.sol",
    "contracts/Frost.sol": "project/contracts/Frost.sol",
    "contracts/Schnorr.sol": "project/contracts/Schnorr.sol",
    "contracts/SchnorrSECP256K1.sol": "project/contracts/SchnorrSECP256K1.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/Ecdsa.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ncontract Ecdsa {\n    // secp256k1n/2\n    uint256 internal constant _HALF_ORDER =\n    0x7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0;\n\n    function toEthSignedMessageHash(bytes32 m) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", m));\n    }\n\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n\n    /// @dev The key fix: check BOTH v values against the expected signer.\n    function isValidSig(address expected, bytes32 m, bytes32 r, bytes32 s) internal pure returns (bool) {\n        uint256 rU = uint256(r);\n        uint256 sU = uint256(s);\n        if (rU == 0 || sU == 0 || sU > _HALF_ORDER) return false;\n        if (ecrecover(m, 27, r, s) == expected) return true;\n        if (ecrecover(m, 28, r, s) == expected) return true;\n        return false;\n    }\n    /// @dev The key fix: check BOTH v values against the expected signer.\n    function isValidSig2(address expected, uint8 v, bytes32 m, bytes32 r, bytes32 s) internal pure returns (bool) {\n        uint256 rU = uint256(r);\n        uint256 sU = uint256(s);\n        if (rU == 0 || sU == 0 || sU > _HALF_ORDER) return false;\n        if (ecrecover(m, v, r, s) == expected) return true;\n        return false;\n    }\n\n    /// @notice raw 32-byte digest check\n    function verifyHash(address expectedSigner, bytes32 m, bytes32 r, bytes32 s)\n    public pure\n    returns (bool)\n    {\n        return isValidSig(expectedSigner, m, r, s);\n    }\n\n    /// @notice EIP-191 (personal_sign) for 32-byte message\n    function verifyPersonalSign(address expectedSigner, uint8 v, bytes32 m, bytes32 r, bytes32 s)\n    public pure\n    returns (bool)\n    {\n        bytes32 digest = toEthSignedMessageHash(m);\n        return isValidSig2(expectedSigner, v,digest, r, s);\n    }\n\n    function measureVerify(\n        address expectedSigner, uint8 v, bytes32 m, bytes32 r, bytes32 s\n    )   external view returns (uint256 cold, uint256 warm) {\n        uint256 g0 = gasleft();\n        require(verifyPersonalSign(  expectedSigner,   v,m,   r,   s), \"cold fail\");\n        uint256 g1 = gasleft();\n        require(verifyPersonalSign(  expectedSigner,   v,m,   r,   s), \"warm fail\");\n        uint256 g2 = gasleft();\n        unchecked {\n            cold = g0 - g1;\n            warm = g1 - g2;\n        }\n    }\n\n    /// @notice EIP-712\n    function verifyTypedData(\n        address expectedSigner,\n        bytes32 domainSeparator,\n        bytes32 structHash,\n        bytes32 r,\n        bytes32 s\n    ) external pure returns (bool) {\n        bytes32 digest = toTypedDataHash(domainSeparator, structHash);\n        return isValidSig(expectedSigner, digest, r, s);\n    }\n}\n"
      },
      "project/contracts/Frost.sol": {
        "content": "//SPDX-License-Identifier: LGPLv3\npragma solidity ^0.8.29;\n\n/// @title FROST Library\n/// @notice Library for verifying FROST(secp256k1, SHA-256) signatures.\n/// @custom:reference <https://datatracker.ietf.org/doc/html/rfc9591>\ncontract Frost {\n    /// @notice The secp256k1 prime field order.\n    uint256 private constant _P = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f;\n    /// @notice The secp256k1 curve order.\n    uint256 private constant _N = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141;\n\n    /// @notice Compute the mul-mul-add operation `-z⋅G + e⋅P` and return the\n    /// hash of the resulting point.\n    /// @dev This function uses a trick to abuse the `ecrecover` precompile in\n    /// order to compute a mul-mul-add operation of `-z` times the curve\n    /// generator point plus `e` time the point `P` defined by the coordinates\n    /// `{x, y}`. The caveat with this trick is that it doesn't return the\n    /// resulting point, but a public address (which is a truncated hash of the\n    /// resulting point's coordinates).\n    /// @param z The scalar to multiply the generator point with.\n    /// @param x The x-coordinate of the point `P`.\n    /// @param y The y-coordinate of the point `P`.\n    /// @param e The scalar to multiple the point `P` with.\n    /// @return result The address corresponding to the point `-z⋅G + e⋅P`.\n    /// @custom:reference <https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384>\n    function _ecmulmuladd(uint256 z, uint256 x, uint256 y, uint256 e) private view returns (address result) {\n        assembly (\"memory-safe\") {\n            let ptr := mload(0x40)\n            mstore(ptr, mulmod(z, x, _N))\n            mstore(add(ptr, 0x20), add(and(y, 1), 27))\n            mstore(add(ptr, 0x40), x)\n            mstore(add(ptr, 0x60), mulmod(e, x, _N))\n            result := mul(mload(0x00), staticcall(gas(), 0x1, ptr, 0x80, 0x00, 0x20))\n        }\n    }\n\n    /// @notice Compute the address corresponding to a point.\n    /// @param x The x-coordinate of the point.\n    /// @param y The y-coordinate of the point.\n    /// @return result The address corresponding to the specified point.\n    function _address(uint256 x, uint256 y) private pure returns (address result) {\n        assembly (\"memory-safe\") {\n            mstore(0x00, x)\n            mstore(0x20, y)\n            result := and(keccak256(0x00, 0x40), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n    }\n\n    /// @notice Checks whether a point is on the curve.\n    /// @param x The x-coordinate of the point.\n    /// @param y The y-coordinate of the point.\n    /// @return result Whether the point is on the curve.\n    function _isOnCurve(uint256 x, uint256 y) private pure returns (bool result) {\n        assembly (\"memory-safe\") {\n            result :=\n            and(eq(mulmod(y, y, _P), addmod(mulmod(x, mulmod(x, x, _P), _P), 7, _P)), and(lt(x, _P), lt(y, _P)))\n        }\n    }\n\n    /// @notice Checks whether an integer is a valid curve scalar.\n    /// @param a The integer to check.\n    /// @return result Whether integer is a valid curve scalar in the range\n    /// `(0, _N)`.\n    function _isScalar(uint256 a) private pure returns (bool result) {\n        assembly (\"memory-safe\") {\n            result := and(gt(a, 0), lt(a, _N))\n        }\n    }\n\n    /// @notice Compute the pre-image to the challenge used for signature\n    /// verification.\n    /// @dev This is the pre-image to the hashing function used in the Schnorr\n    /// signature scheme and is the concatenation of the group commitment point\n    /// `R` from FROST signature, the group public key point `P` and the signed\n    /// message. Points are both in SEC1 compressed form.\n    /// @custom:note There is no restriction to the length of `message`, but we\n    /// keep it to a constant 32 bytes in our implementation, since almost all\n    /// on-chain signature verification uses 32-byte signing messages.\n    /// @param rx The x-coordinate of the signature point `R`.\n    /// @param ry The y-coordinate of the signature point `R`.\n    /// @param px The x-coordinate of the public key point `P`.\n    /// @param py The y-coordinate of the public key point `P`.\n    /// @param message The signed message.\n    /// @return preimage The pre-image bytes.\n    /// @custom:reference <https://datatracker.ietf.org/doc/html/rfc9591#section-4.6>\n    /// @custom:reference <https://secg.org/sec1-v2.pdf>\n    function _preimage(uint256 rx, uint256 ry, uint256 px, uint256 py, bytes32 message)\n    private\n    pure\n    returns (bytes memory preimage)\n    {\n        preimage = new bytes(98);\n        assembly (\"memory-safe\") {\n            mstore8(add(preimage, 0x20), add(2, and(ry, 1)))\n            mstore(add(preimage, 0x21), rx)\n            mstore8(add(preimage, 0x41), add(2, and(py, 1)))\n            mstore(add(preimage, 0x42), px)\n            mstore(add(preimage, 0x62), message)\n        }\n    }\n\n    /// @notice Expands `message` to generate a uniformly random byte string.\n    /// @dev This uses the XMD variant of message expansion, as specified by\n    /// the hashing function for FROST(secp256k1, SHA-256).\n    /// @param message The message to expand.\n    /// @param dst The domain separation tag.\n    /// @param len The number of uniformly random bytes to generate.\n    /// @return uniform `len` uniformly random bytes.\n    /// @custom:reference <https://datatracker.ietf.org/doc/html/rfc9380#section-5.3.1>\n    /// @custom:reference <https://datatracker.ietf.org/doc/html/rfc9591#section-6.5>\n    function _expandMessageXmd(bytes memory message, string memory dst, uint256 len)\n    private\n    view\n    returns (bytes memory uniform)\n    {\n        assembly (\"memory-safe\") {\n            uniform := mload(0x40)\n            mstore(0x40, add(uniform, and(add(0x3f, len), 0xffe0)))\n            mstore(uniform, len)\n\n            let prime := mload(0x40)\n            let ptr := prime\n\n            mstore(ptr, 0)\n            ptr := add(ptr, 0x20)\n            mstore(ptr, 0)\n            ptr := add(ptr, 0x20)\n\n            mcopy(ptr, add(message, 0x20), mload(message))\n            ptr := add(ptr, mload(message))\n            mstore(ptr, shl(240, len))\n            ptr := add(ptr, 3)\n\n            let bPtr := sub(ptr, 0x21)\n            let iPtr := sub(ptr, 0x01)\n\n            mcopy(ptr, add(dst, 0x20), mload(dst))\n            ptr := add(ptr, mload(dst))\n            mstore8(ptr, mload(dst))\n            ptr := add(ptr, 0x01)\n\n            let bLen := sub(ptr, bPtr)\n\n            if iszero(staticcall(gas(), 0x2, prime, sub(ptr, prime), bPtr, 0x20)) {revert(0x00, 0x00)}\n            let b0 := mload(bPtr)\n            mstore8(iPtr, 1)\n            if iszero(staticcall(gas(), 0x2, bPtr, bLen, add(uniform, 0x20), 0x20)) {revert(0x00, 0x00)}\n            for {let i := 2} gt(len, 0x20) {\n                i := add(i, 1)\n                len := sub(len, 32)\n            } {\n                let uPtr := add(uniform, shl(5, i))\n                mstore(bPtr, xor(b0, mload(sub(uPtr, 0x20))))\n                mstore8(iPtr, i)\n                if iszero(staticcall(gas(), 0x2, bPtr, bLen, uPtr, 0x20)) {revert(0x00, 0x00)}\n            }\n        }\n    }\n\n    /// @notice Hash a `message` to a field element.\n    /// @dev It is somewhat confusing, but the hashing functions from\n    /// FROST(secp256k1, SHA-256) are specified to use the curve order instead\n    /// of the field order. This makes sense because:\n    /// 1. The curve order is also prime, and so also forms a prime field.\n    /// 2. The scalar is multiplied by a point during signature verification\n    ///    meaning that only values `[0, _N)` produce unique points.\n    /// @param message The message to hash.\n    /// @param dst The domain separation tag.\n    /// @return e The hashed message as a field element.\n    /// @custom:reference <https://datatracker.ietf.org/doc/html/rfc9380#section-5.3.1>\n    /// @custom:reference <https://datatracker.ietf.org/doc/html/rfc9591#section-6.5>\n    function _hashToField(bytes memory message, string memory dst) private view returns (uint256 e) {\n        bytes memory uniform = _expandMessageXmd(message, dst, 48);\n        assembly (\"memory-safe\") {\n            e := mulmod(mload(add(uniform, 0x20)), 0x100000000000000000000000000000000, _N)\n            e := addmod(e, shr(128, mload(add(uniform, 0x40))), _N)\n        }\n    }\n\n    /// @notice Computes the challenge for the FROST(secp256k1, SHA-256)\n    /// Schnorr signature.\n    /// @dev Defined as the H2 hashing function for FROST(secp256k1, SHA-256).\n    /// @custom:note There is no restriction to the length of `message`, but we\n    /// keep it to a constant 32 bytes in our implementation, since almost all\n    /// on-chain signature verification uses 32-byte signing messages.\n    /// @param rx The x-coordinate of the signature point `R`.\n    /// @param ry The y-coordinate of the signature point `R`.\n    /// @param px The x-coordinate of the public key point `P`.\n    /// @param py The y-coordinate of the public key point `P`.\n    /// @param message The signed message.\n    /// @return e The Schnorr signature challenge.\n    /// @custom:reference <https://datatracker.ietf.org/doc/html/rfc9591#section-6.5>\n    function _challenge(uint256 rx, uint256 ry, uint256 px, uint256 py, bytes32 message)\n    private\n    view\n    returns (uint256 e)\n    {\n        return _hashToField(_preimage(rx, ry, px, py, message), \"FROST-secp256k1-SHA256-v1chal\");\n    }\n\n    /// @notice Checks whether a point is on the curve and is a supported FROST\n    /// public key.\n    /// @dev In addition to being a valid point of the curve, the `x`-coordinate\n    /// of the public key must be smaller than the curve order for the math trick\n    /// with `ecrecover` to work and supported by this verifier implementation.\n    /// @param x The x-coordinate of the point.\n    /// @param y The y-coordinate of the point.\n    /// @return result Whether the point is valid and supported.\n    function isValidPublicKey(uint256 x, uint256 y) internal pure returns (bool result) {\n        assembly (\"memory-safe\") {\n            result :=\n            and(eq(mulmod(y, y, _P), addmod(mulmod(x, mulmod(x, x, _P), _P), 7, _P)), and(lt(x, _N), lt(y, _P)))\n        }\n    }\n\n    /// @notice Verify a FROST(secp256k1, SHA-256) Schnorr signature.\n    /// @dev Note that public key's x-coordinate `px` must be smaller than the\n    /// curve order for the math trick with `ecrecover` to work. You must use\n    /// public keys that have been checked with `FROST.isValidPublicKey(px, py)`,\n    /// as not all public keys are supported by this verifier implementation.\n    /// @custom:note There is no restriction to the length of `message`, but we\n    /// keep it to a constant 32 bytes in our implementation, since almost all\n    /// on-chain signature verification uses 32-byte signing messages.\n    /// @param message The signed message.\n    /// @param rx The x-coordinate of the signature point `R`.\n    /// @param ry The y-coordinate of the signature point `R`.\n    /// @param px The x-coordinate of the public key point `P`.\n    /// @param py The y-coordinate of the public key point `P`.\n    /// @param z The z-scalar of the signature.\n    /// @return signer The address of the public key point `P`, or `0` if\n    /// signature verification failed.\n    /// @custom:reference <https://datatracker.ietf.org/doc/html/rfc9591#section-6.5>\n    /// @custom:reference <https://en.wikipedia.org/wiki/Schnorr_signature#Verifying>\n    /// @custom:reference <https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/19>\n    function verify(bytes32 message, uint256 px, uint256 py, uint256 rx, uint256 ry, uint256 z)\n    public view\n    returns (address signer)\n    {\n        // This is where the madness happens!\n        //\n        // Schnorr signature verification is fairly straight forward. Given:\n        // - generator point `G`\n        // - message bytes `MSG`\n        // - public key point `P`\n        // - signature point `R`\n        // - signature scalar `z`\n        // - hashing function `H` (`H2` from the FROST(secp256k1, SHA-256)\n        //   specification - used in computing the signature `_challenge`)\n        //\n        // Let `e` be the signature challenge computed by applying the hashing\n        // function `H` to `R`, `P` and `MSG` (note that for FROST, the points\n        // are encoded in SEC1 compressed form):\n        //      e = H(R || P || MSG)\n        //\n        // The goal is to show that:\n        //      z⋅G - H(R || P || MSG)⋅P = R\n        //                     z⋅G - e⋅P = R\n        //\n        // If we abuse the `ecrecover` mul-mul-add trick, we get a convienient\n        // way of computing:\n        //      address(-z⋅G + e⋅P) = address(-(z⋅G - e⋅P))\n        //                         = address(-(z⋅G - H(R || P || MSG)⋅P))\n        //                         = address(-R)\n        //\n        // We can trivially compute the additive inverse `-R` of `R`:\n        //      -R = {rx,-ry}\n        //\n        // This means you just need to compute the additive inverse of its\n        // y-coordinate `ry` in the curve's finite field:\n        //      -ry = (_P - ry) % _P\n        //          = _P - ry\n        //\n        // We can omit the modulus since `ry` is already an element of the\n        // curve's finite field and thus in the range `[0, _P)`.\n        //\n        // Note that Schnorr lacks standardization, and in some schemes you\n        // compute `z⋅G - e⋅P = R` and in others `z⋅G + e⋅P = R`. The math\n        // works out to the same in the end - you just need to be careful about\n        // the sign of the scalars from the signature. FROST in particular uses\n        // the former construction.\n\n        // TODO(nlordell): I don't think this is required for Schnorr\n        // signatures, but do it anyway for now just in case. At least, this\n        // prevents some signature malleability with `z` (since it gets mapped\n        // to a curve scalar, there are some values of `z` that can be\n        // specified in more than one way.\n        {\n            bool pOk = isValidPublicKey(px, py);\n            bool rOk = _isOnCurve(rx, ry);\n            bool zOk = _isScalar(z);\n            bool ok;\n            assembly (\"memory-safe\") {\n                ok := and(pOk, and(rOk, zOk))\n            }\n\n            if (!ok) {\n                return address(0);\n            }\n        }\n\n        uint256 e = _challenge(rx, ry, px, py, message);\n        unchecked {\n            address minusR = _address(rx, _P - ry); // address(-R)\n            address minusRv = _ecmulmuladd(z, px, py, e); // address(-z⋅G + e⋅P)\n\n            signer = _address(px, py);\n            assembly (\"memory-safe\") {\n                signer := mul(signer, eq(minusR, minusRv))\n            }\n        }\n    }\n\n    function measureVerify(\n        bytes32 message, uint256 px, uint256 py, uint256 rx, uint256 ry, uint256 z\n    ) external view returns (uint256 cold, uint256 warm) {\n        uint256 g0 = gasleft();\n        verify(message, px, py, rx, ry, z);\n        uint256 g1 = gasleft();\n        verify(message, px, py, rx, ry, z);\n        uint256 g2 = gasleft();\n        unchecked {\n            cold = g0 - g1;\n            warm = g1 - g2;\n        }\n    }\n}\n"
      },
      "project/contracts/Schnorr.sol": {
        "content": "//SPDX-License-Identifier: LGPLv3\npragma solidity ^0.8.29;\n\ncontract Schnorr {\n    // secp256k1 group order\n    uint256 constant public Q =\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n\n    // parity := public key y-coord parity (27 or 28)\n    // px := public key x-coord\n    // message := 32-byte message\n    // e := schnorr signature challenge\n    // s := schnorr signature\n    function verify(\n        uint8 parity,\n        bytes32 px,\n        bytes32 message,\n        bytes32 e,\n        bytes32 s\n    ) public pure returns (bool) {\n        // ecrecover = (m, v, r, s);\n        bytes32 sp = bytes32(Q - mulmod(uint256(s), uint256(px), Q));\n        bytes32 ep = bytes32(Q - mulmod(uint256(e), uint256(px), Q));\n\n        require(sp != 0);\n        // the ecrecover precompile implementation checks that the `r` and `s`\n        // inputs are non-zero (in this case, `px` and `ep`), thus we don't need to\n        // check if they're zero.\n        address R = ecrecover(sp, parity, px, ep);\n        require(R != address(0), \"ecrecover failed\");\n        return e == keccak256(\n            abi.encodePacked(R, uint8(parity), px, message)\n        );\n    }\n\n    function measureVerify(\n        uint8 parity,\n        bytes32 px,\n        bytes32 message,\n        bytes32 e,\n        bytes32 s\n    ) external returns (uint256 cold, uint256 warm) {\n        uint256 g0 = gasleft();\n        require(verify(parity, px, message, e, s), \"cold fail\");\n        uint256 g1 = gasleft();\n        require(verify(parity, px, message, e, s), \"warm fail\");\n        uint256 g2 = gasleft();\n        unchecked {\n            cold = g0 - g1;\n            warm = g1 - g2;\n        }\n    }\n}\n"
      },
      "project/contracts/SchnorrSECP256K1.sol": {
        "content": "///////////////////////////////////////////////////////////////////////////////\n//       XXX: Do not use in production until this code has been audited.\n////////////////////////////////////////////////////////////////////////////////\n\ncontract SchnorrSECP256K1 {\n    // See https://en.bitcoin.it/wiki/Secp256k1 for this constant.\n    uint256 constant public Q = // Group order of secp256k1\n    // solium-disable-next-line indentation\n    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\n    // solium-disable-next-line zeppelin/no-arithmetic-operations\n    uint256 constant public HALF_Q = (Q >> 1) + 1;\n\n    /** **************************************************************************\n@notice verifySignature returns true iff passed a valid Schnorr signature.\n\n      @dev See https://en.wikipedia.org/wiki/Schnorr_signature for reference.\n\n      @dev In what follows, let d be your secret key, PK be your public key,\n      PKx be the x ordinate of your public key, and PKyp be the parity bit for\n      the y ordinate (i.e., 0 if PKy is even, 1 if odd.)\n      **************************************************************************\n      @dev TO CREATE A VALID SIGNATURE FOR THIS METHOD\n\n      @dev First PKx must be less than HALF_Q. Then follow these instructions\n           (see evm/test/schnorr_test.js, for an example of carrying them out):\n      @dev 1. Hash the target message to a uint256, called msgHash here, using\n              keccak256\n\n      @dev 2. Pick k uniformly and cryptographically securely randomly from\n              {0,...,Q-1}. It is critical that k remains confidential, as your\n              private key can be reconstructed from k and the signature.\n\n      @dev 3. Compute k*g in the secp256k1 group, where g is the group\n              generator. (This is the same as computing the public key from the\n              secret key k. But it's OK if k*g's x ordinate is greater than\n              HALF_Q.)\n\n      @dev 4. Compute the ethereum address for k*g. This is the lower 160 bits\n              of the keccak hash of the concatenated affine coordinates of k*g,\n              as 32-byte big-endians. (For instance, you could pass k to\n              ethereumjs-utils's privateToAddress to compute this, though that\n              should be strictly a development convenience, not for handling\n              live secrets, unless you've locked your javascript environment\n              down very carefully.) Call this address\n              nonceTimesGeneratorAddress.\n\n      @dev 5. Compute e=uint256(keccak256(PKx as a 32-byte big-endian\n                                        ‖ PKyp as a single byte\n                                        ‖ msgHash\n                                        ‖ nonceTimesGeneratorAddress))\n              This value e is called \"msgChallenge\" in verifySignature's source\n              code below. Here \"‖\" means concatenation of the listed byte\n              arrays.\n\n      @dev 6. Let x be your secret key. Compute s = (k - d * e) % Q. Add Q to\n              it, if it's negative. This is your signature. (d is your secret\n              key.)\n      **************************************************************************\n      @dev TO VERIFY A SIGNATURE\n\n      @dev Given a signature (s, e) of msgHash, constructed as above, compute\n      S=e*PK+s*generator in the secp256k1 group law, and then the ethereum\n      address of S, as described in step 4. Call that\n      nonceTimesGeneratorAddress. Then call the verifySignature method as:\n\n      @dev    verifySignature(PKx, PKyp, s, msgHash,\n                              nonceTimesGeneratorAddress)\n      **************************************************************************\n      @dev This signging scheme deviates slightly from the classical Schnorr\n      signature, in that the address of k*g is used in place of k*g itself,\n      both when calculating e and when verifying sum S as described in the\n      verification paragraph above. This reduces the difficulty of\n      brute-forcing a signature by trying random secp256k1 points in place of\n      k*g in the signature verification process from 256 bits to 160 bits.\n      However, the difficulty of cracking the public key using \"baby-step,\n      giant-step\" is only 128 bits, so this weakening constitutes no compromise\n      in the security of the signatures or the key.\n\n      @dev The constraint signingPubKeyX < HALF_Q comes from Eq. (281), p. 24\n      of Yellow Paper version 78d7b9a. ecrecover only accepts \"s\" inputs less\n      than HALF_Q, to protect against a signature- malleability vulnerability in\n      ECDSA. Schnorr does not have this vulnerability, but we must account for\n      ecrecover's defense anyway. And since we are abusing ecrecover by putting\n      signingPubKeyX in ecrecover's \"s\" argument the constraint applies to\n      signingPubKeyX, even though it represents a value in the base field, and\n      has no natural relationship to the order of the curve's cyclic group.\n      **************************************************************************\n      @param signingPubKeyX is the x ordinate of the public key. This must be\n             less than HALF_Q.\n      @param pubKeyYParity is 0 if the y ordinate of the public key is even, 1\n             if it's odd.\n      @param signature is the actual signature, described as s in the above\n             instructions.\n      @param msgHash is a 256-bit hash of the message being signed.\n      @param nonceTimesGeneratorAddress is the ethereum address of k*g in the\n             above instructions\n      **************************************************************************\n      @return True if passed a valid signature, false otherwise. */\n    function verifySignature(\n        uint256 signingPubKeyX,\n        uint8 pubKeyYParity,\n        uint256 signature,\n        uint256 msgHash,\n        address nonceTimesGeneratorAddress) public pure returns (bool) {\n        //require(signingPubKeyX < HALF_Q, \"Public-key x >= HALF_Q\");\n        // Avoid signature malleability from multiple representations for ℤ/Qℤ elts\n        require(signature < Q, \"signature must be reduced modulo Q\");\n\n        // Forbid trivial inputs, to avoid ecrecover edge cases. The main thing to\n        // avoid is something which causes ecrecover to return 0x0: then trivial\n        // signatures could be constructed with the nonceTimesGeneratorAddress input\n        // set to 0x0.\n        //\n        // solium-disable-next-line indentation\n        require(nonceTimesGeneratorAddress != address(0) && signingPubKeyX > 0 &&\n        signature > 0 && msgHash > 0, \"no zero inputs allowed\");\n\n        uint256 pxB32Canob = signingPubKeyX;\n        uint8 vCanon = pubKeyYParity;\n        if (signingPubKeyX > HALF_Q) {\n            pxB32Canob  = Q - signingPubKeyX;\n            vCanon = 55 - pubKeyYParity;\n        }\n        // solium-disable-next-line indentation\n        uint256 msgChallenge =\n                            uint256(keccak256(abi.encodePacked(pxB32Canob, vCanon,\n                msgHash, nonceTimesGeneratorAddress))\n            );\n\n        // Verify msgChallenge * signingPubKey + signature * generator ==\n        //        nonce * generator\n        //\n        // https://ethresear.ch/t/you-can-kinda-abuse-ecrecover-to-do-ecmul-in-secp256k1-today/2384/9\n        // The point corresponding to the address returned by\n        // ecrecover(-s*r,v,r,e*r) is (r⁻¹ mod Q)*(e*r*R-(-s)*r*g)=e*R+s*g, where R\n        // is the (v,r) point. See https://crypto.stackexchange.com/a/18106\n        //\n        // solium-disable-next-line indentation\n        address recoveredAddress = ecrecover(\n        // solium-disable-next-line zeppelin/no-arithmetic-operations\n            bytes32(Q - mulmod(signingPubKeyX, signature, Q)),\n            // https://ethereum.github.io/yellowpaper/paper.pdf p. 24, \"The\n            // value 27 represents an even y value and 28 represents an odd\n            // y value.\"\n            pubKeyYParity,\n            bytes32(signingPubKeyX),\n            bytes32(mulmod(msgChallenge, signingPubKeyX, Q)));\n        return nonceTimesGeneratorAddress == recoveredAddress;\n    }\n\n    function measureVerify(\n        uint256 signingPubKeyX,\n        uint8 pubKeyYParity,\n        uint256 signature,\n        uint256 msgHash,\n        address nonceTimesGeneratorAddress\n    ) public returns (uint256 cold, uint256 warm) {\n        uint256 g0 = gasleft();\n        require(verifySignature(\n            signingPubKeyX,\n            pubKeyYParity,\n            signature,\n            msgHash,\n            nonceTimesGeneratorAddress), \"cold fail\");\n        uint256 g1 = gasleft();\n        require(verifySignature(\n            signingPubKeyX,\n            pubKeyYParity,\n            signature,\n            msgHash,\n            nonceTimesGeneratorAddress), \"warm fail\");\n        uint256 g2 = gasleft();\n        unchecked {\n            cold = g0 - g1;\n            warm = g1 - g2;\n        }\n    }\n}\n"
      }
    }
  }
}